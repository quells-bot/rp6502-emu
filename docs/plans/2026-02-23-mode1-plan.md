# Mode 1 (Character) Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add Mode 1 (Character) rendering to the emulator with all 5 color depths, both font sizes, and built-in CP437 fonts.

**Architecture:** A new `mode1.rs` module mirrors `mode3.rs` structure: config struct, format enum, per-scanline renderer. A new `font.rs` embeds built-in CP437 font data. The VGA state machine uses a `Plane` enum to dispatch between Mode 1 and Mode 3. Palette resolution is shared between modes.

**Tech Stack:** Rust, existing `emu/` crate

---

### Task 1: Generate font.rs with built-in CP437 font data

The firmware stores fonts in separate ASCII (glyphs 0-127) and code page (glyphs 128-255) arrays, then combines them at runtime into "wide" format: `font[row * 256 + glyph_code]`. We need a Python script to extract, combine, and output Rust const arrays.

**Files:**
- Create: `emu/scripts/gen_font.py`
- Create: `emu/src/vga/font.rs`
- Modify: `emu/src/vga/mod.rs:1` (add `pub mod font;`)

**Step 1: Write the font generation script**

Create `emu/scripts/gen_font.py`:

```python
#!/usr/bin/env python3
"""Extract CP437 font data from firmware font.c and generate Rust source."""

import re
import sys
from pathlib import Path

def extract_hex_array(source: str, name: str) -> list[int]:
    """Extract a C hex array by name, return list of byte values."""
    # Match: static const ... uint8_t NAME[] = { ... };
    pattern = rf'uint8_t\s+{name}\s*\[\s*\]\s*=\s*\{{([^}}]+)\}}'
    m = re.search(pattern, source, re.DOTALL)
    if not m:
        raise ValueError(f"Array {name} not found")
    hex_str = m.group(1)
    # Parse hex values like 0x00, 0x7e, etc.
    return [int(x, 16) for x in re.findall(r'0x[0-9a-fA-F]+', hex_str)]

def interleave_font(ascii_data: list[int], cp_data: list[int], rows: int) -> list[int]:
    """Combine ASCII (glyphs 0-127) and code page (glyphs 128-255) into wide format.

    Input: each array is rows * 128 bytes (128 bytes per row, one byte per glyph).
    Output: rows * 256 bytes (256 bytes per row, full glyph set).

    This matches firmware font_init():
      font[row*256 + 0..127]   = ASCII[row*128 + 0..127]
      font[row*256 + 128..255] = CP[row*128 + 0..127]
    """
    assert len(ascii_data) == rows * 128, f"ASCII: expected {rows*128}, got {len(ascii_data)}"
    assert len(cp_data) == rows * 128, f"CP: expected {rows*128}, got {len(cp_data)}"

    result = []
    for row in range(rows):
        result.extend(ascii_data[row*128 : (row+1)*128])
        result.extend(cp_data[row*128 : (row+1)*128])
    return result

def format_rust_array(name: str, data: list[int], line_width: int = 16) -> str:
    """Format as a Rust const array."""
    lines = [f"pub const {name}: [u8; {len(data)}] = ["]
    for i in range(0, len(data), line_width):
        chunk = data[i:i+line_width]
        hex_vals = ", ".join(f"0x{b:02X}" for b in chunk)
        lines.append(f"    {hex_vals},")
    lines.append("];")
    return "\n".join(lines)

def main():
    font_c = Path(__file__).parent.parent.parent / "firmware" / "src" / "vga" / "term" / "font.c"
    if not font_c.exists():
        print(f"Error: {font_c} not found", file=sys.stderr)
        sys.exit(1)

    source = font_c.read_text()

    font8_ascii = extract_hex_array(source, "FONT8_ASCII")
    font8_cp437 = extract_hex_array(source, "FONT8_CP437")
    font16_ascii = extract_hex_array(source, "FONT16_ASCII")
    font16_cp437 = extract_hex_array(source, "FONT16_CP437")

    font8 = interleave_font(font8_ascii, font8_cp437, 8)
    font16 = interleave_font(font16_ascii, font16_cp437, 16)

    assert len(font8) == 2048
    assert len(font16) == 4096

    out = [
        "/// Built-in CP437 (American English) fonts, IBM VGA typeface.",
        "///",
        "/// \"Wide\" format: `font[row * 256 + glyph_code]` gives one byte",
        "/// (8 pixels, MSB = leftmost) for that glyph at that row.",
        "///",
        "/// Generated from firmware/src/vga/term/font.c by scripts/gen_font.py.",
        "/// SPDX-License-Identifier: BSD-3-Clause",
        "",
        f"/// 8x8 font: 256 glyphs, 8 rows per glyph, 1 byte per row.",
        format_rust_array("FONT8", font8),
        "",
        f"/// 8x16 font: 256 glyphs, 16 rows per glyph, 1 byte per row.",
        format_rust_array("FONT16", font16),
        "",
        "#[cfg(test)]",
        "mod tests {",
        "    use super::*;",
        "",
        "    #[test]",
        "    fn test_font8_size() {",
        "        assert_eq!(FONT8.len(), 2048);",
        "    }",
        "",
        "    #[test]",
        "    fn test_font16_size() {",
        "        assert_eq!(FONT16.len(), 4096);",
        "    }",
        "",
        "    #[test]",
        "    fn test_font8_space_is_blank() {",
        "        // Space (glyph 0x20) should be all zeros in 8x8 font",
        "        for row in 0..8 {",
        "            assert_eq!(FONT8[row * 256 + 0x20], 0, \"row {row}\");",
        "        }",
        "    }",
        "",
        "    #[test]",
        "    fn test_font16_space_is_blank() {",
        "        for row in 0..16 {",
        "            assert_eq!(FONT16[row * 256 + 0x20], 0, \"row {row}\");",
        "        }",
        "    }",
        "",
        "    #[test]",
        "    fn test_font8_A_has_content() {",
        "        // 'A' (glyph 0x41) should have non-zero rows",
        "        let mut has_content = false;",
        "        for row in 0..8 {",
        "            if FONT8[row * 256 + 0x41] != 0 {",
        "                has_content = true;",
        "            }",
        "        }",
        "        assert!(has_content, \"glyph 'A' should have visible pixels\");",
        "    }",
        "",
        "    #[test]",
        "    fn test_font16_A_has_content() {",
        "        let mut has_content = false;",
        "        for row in 0..16 {",
        "            if FONT16[row * 256 + 0x41] != 0 {",
        "                has_content = true;",
        "            }",
        "        }",
        "        assert!(has_content, \"glyph 'A' should have visible pixels\");",
        "    }",
        "",
        "    #[test]",
        "    fn test_font8_high_glyph_has_content() {",
        "        // CP437 glyph 0xDB (full block) should be all 0xFF",
        "        for row in 0..8 {",
        "            assert_eq!(FONT8[row * 256 + 0xDB], 0xFF, \"row {row}\");",
        "        }",
        "    }",
        "}",
        "",
    ]

    out_path = Path(__file__).parent.parent / "src" / "vga" / "font.rs"
    out_path.write_text("\n".join(out))
    print(f"Generated {out_path} ({len(font8) + len(font16)} bytes of font data)")

if __name__ == "__main__":
    main()
```

**Step 2: Run the script to generate font.rs**

Run: `cd /home/sprite/rp6502 && python3 emu/scripts/gen_font.py`
Expected: Creates `emu/src/vga/font.rs` with FONT8 and FONT16 arrays.

**Step 3: Add `pub mod font;` to vga/mod.rs**

In `emu/src/vga/mod.rs`, add after line 2 (`pub mod palette;`):

```rust
pub mod font;
```

**Step 4: Run tests to verify font data**

Run: `cd /home/sprite/rp6502/emu && cargo test vga::font -- --nocapture`
Expected: All 6 font tests pass.

**Step 5: Commit**

```bash
git add emu/scripts/gen_font.py emu/src/vga/font.rs emu/src/vga/mod.rs
git commit -m "feat: add built-in CP437 font data for Mode 1

Generated from firmware font.c by scripts/gen_font.py.
8x8 (2048 bytes) and 8x16 (4096 bytes) in wide format."
```

---

### Task 2: Extract shared palette resolution to palette.rs

Mode 1 uses the same palette resolution logic as Mode 3. Extract the function to `palette.rs` so both modes can share it.

**Files:**
- Modify: `emu/src/vga/palette.rs:103` (add `resolve_palette` function)
- Modify: `emu/src/vga/mode3.rs:111-161` (replace local `resolve_palette` with call to shared version)

**Step 1: Add shared `resolve_palette` to palette.rs**

Add after the `rgb565_to_rgba` function (after line 103 in `emu/src/vga/palette.rs`):

```rust
/// Resolve palette for a given bits-per-pixel from XRAM or built-in.
///
/// Shared between Mode 1 and Mode 3. Mirrors firmware palette resolution:
/// - palette_ptr must be even (word-aligned) and fit in XRAM
/// - 1bpp falls back to PALETTE_2
/// - all others fall back to PALETTE_256 (truncated to 1 << bpp)
/// - 16bpp returns empty vec (direct color, no palette needed)
///
/// Note: palette_ptr == 0 is treated as "use built-in" (documented divergence
/// from firmware which would read XRAM[0]).
pub fn resolve_palette(xram: &[u8; 65536], bpp: u32, palette_ptr: u16) -> Vec<u32> {
    if bpp >= 16 {
        return vec![];
    }

    let count = 1usize << bpp;

    if palette_ptr & 1 == 0
        && palette_ptr > 0
        && (palette_ptr as usize + count * 2) <= 0x10000
    {
        let mut pal = Vec::with_capacity(count);
        for i in 0..count {
            let offset = palette_ptr as usize + i * 2;
            let raw = u16::from_le_bytes([xram[offset], xram[offset + 1]]);
            pal.push(rgb565_to_rgba(raw));
        }
        pal
    } else if bpp == 1 {
        PALETTE_2.to_vec()
    } else {
        PALETTE_256[..count].to_vec()
    }
}
```

**Step 2: Add a test for the shared function**

Add to the `#[cfg(test)] mod tests` block in `palette.rs`:

```rust
#[test]
fn test_resolve_palette_builtin_1bpp() {
    let xram = Box::new([0u8; 65536]);
    let pal = resolve_palette(&xram, 1, 0);
    assert_eq!(pal.len(), 2);
    assert_eq!(pal[0], PALETTE_2[0]);
    assert_eq!(pal[1], PALETTE_2[1]);
}

#[test]
fn test_resolve_palette_builtin_8bpp() {
    let xram = Box::new([0u8; 65536]);
    let pal = resolve_palette(&xram, 8, 0);
    assert_eq!(pal.len(), 256);
    assert_eq!(pal[1], PALETTE_256[1]);
}

#[test]
fn test_resolve_palette_16bpp_empty() {
    let xram = Box::new([0u8; 65536]);
    let pal = resolve_palette(&xram, 16, 0);
    assert!(pal.is_empty());
}
```

**Step 3: Run palette tests**

Run: `cd /home/sprite/rp6502/emu && cargo test vga::palette -- --nocapture`
Expected: All palette tests pass (existing + new).

**Step 4: Update mode3.rs to use shared `resolve_palette`**

In `emu/src/vga/mode3.rs`:

1. Change the import at line 1 from:
```rust
use super::palette::{PALETTE_2, PALETTE_256, rgb565_to_rgba};
```
to:
```rust
use super::palette::{resolve_palette, rgb565_to_rgba};
```

2. Delete the entire local `resolve_palette` function (lines 111-161).

3. In `render_mode3` (around current line 254), change:
```rust
let palette = resolve_palette(xram, &plane.format, cfg.xram_palette_ptr);
```
to:
```rust
let palette = resolve_palette(xram, plane.format.bits_per_pixel(), cfg.xram_palette_ptr);
```

**Step 5: Run all tests**

Run: `cd /home/sprite/rp6502/emu && cargo test`
Expected: All tests pass.

**Step 6: Commit**

```bash
git add emu/src/vga/palette.rs emu/src/vga/mode3.rs
git commit -m "refactor: extract shared palette resolution to palette.rs

Both Mode 1 and Mode 3 use the same palette lookup logic.
Move resolve_palette to palette.rs parameterized by bpp."
```

---

### Task 3: Create mode1.rs with config, format, and renderer

This is the core rendering module. It follows the firmware's `mode1.c` structure but uses a simpler pixel-by-pixel approach instead of the firmware's optimized chunk rendering.

**Files:**
- Create: `emu/src/vga/mode1.rs`
- Modify: `emu/src/vga/mod.rs:1-3` (add `pub mod mode1;`)

**Reference files (read before implementing):**
- `firmware/src/vga/modes/mode1.c` — rendering logic, data struct layouts
- `emu/src/vga/mode3.rs` — pattern to follow for Config, Plane, render
- `pico-docs/docs/source/vga.rst` lines 153-250 — Mode 1 spec

**Step 1: Create mode1.rs with types**

Create `emu/src/vga/mode1.rs`:

```rust
use super::font::{FONT8, FONT16};
use super::palette::{resolve_palette, rgb565_to_rgba};

/// Mode 1 configuration, read from XRAM at config_ptr.
/// Matches firmware mode1_config_t exactly (16 bytes):
///   bool x_wrap           (1 byte, offset 0)
///   bool y_wrap           (1 byte, offset 1)
///   int16_t x_pos_px      (2 bytes, offset 2)
///   int16_t y_pos_px      (2 bytes, offset 4)
///   int16_t width_chars   (2 bytes, offset 6)
///   int16_t height_chars  (2 bytes, offset 8)
///   uint16_t xram_data_ptr    (2 bytes, offset 10)
///   uint16_t xram_palette_ptr (2 bytes, offset 12)
///   uint16_t xram_font_ptr    (2 bytes, offset 14)
#[derive(Debug, Clone)]
pub struct Mode1Config {
    pub x_wrap: bool,
    pub y_wrap: bool,
    pub x_pos_px: i16,
    pub y_pos_px: i16,
    pub width_chars: i16,
    pub height_chars: i16,
    pub xram_data_ptr: u16,
    pub xram_palette_ptr: u16,
    pub xram_font_ptr: u16,
}

/// Mode 1 format, encoding both font size and color depth.
/// Matches firmware mode1_prog() attribute switch.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Mode1Format {
    Bpp1_8x8,    // attr 0
    Bpp4r_8x8,   // attr 1: 4bpp reversed (fg_bg nibble order)
    Bpp4_8x8,    // attr 2: 4bpp normal (bg_fg nibble order)
    Bpp8_8x8,    // attr 3
    Bpp16_8x8,   // attr 4
    Bpp1_8x16,   // attr 8
    Bpp4r_8x16,  // attr 9
    Bpp4_8x16,   // attr 10
    Bpp8_8x16,   // attr 11
    Bpp16_8x16,  // attr 12
}

impl Mode1Format {
    pub fn from_attr(attr: u16) -> Option<Self> {
        match attr {
            0 => Some(Self::Bpp1_8x8),
            1 => Some(Self::Bpp4r_8x8),
            2 => Some(Self::Bpp4_8x8),
            3 => Some(Self::Bpp8_8x8),
            4 => Some(Self::Bpp16_8x8),
            8 => Some(Self::Bpp1_8x16),
            9 => Some(Self::Bpp4r_8x16),
            10 => Some(Self::Bpp4_8x16),
            11 => Some(Self::Bpp8_8x16),
            12 => Some(Self::Bpp16_8x16),
            _ => None,
        }
    }

    /// Font height in pixels.
    pub fn font_height(&self) -> i16 {
        match self {
            Self::Bpp1_8x8 | Self::Bpp4r_8x8 | Self::Bpp4_8x8
            | Self::Bpp8_8x8 | Self::Bpp16_8x8 => 8,
            _ => 16,
        }
    }

    /// Bytes per character cell in the data array.
    pub fn cell_size(&self) -> usize {
        match self {
            Self::Bpp1_8x8 | Self::Bpp1_8x16 => 1,
            Self::Bpp4r_8x8 | Self::Bpp4_8x8
            | Self::Bpp4r_8x16 | Self::Bpp4_8x16 => 2,
            Self::Bpp8_8x8 | Self::Bpp8_8x16 => 3,
            Self::Bpp16_8x8 | Self::Bpp16_8x16 => 6,
        }
    }

    /// Bits per pixel for palette resolution.
    fn bpp(&self) -> u32 {
        match self {
            Self::Bpp1_8x8 | Self::Bpp1_8x16 => 1,
            Self::Bpp4r_8x8 | Self::Bpp4_8x8
            | Self::Bpp4r_8x16 | Self::Bpp4_8x16 => 4,
            Self::Bpp8_8x8 | Self::Bpp8_8x16 => 8,
            Self::Bpp16_8x8 | Self::Bpp16_8x16 => 16,
        }
    }
}

/// A programmed Mode 1 plane.
#[derive(Debug, Clone)]
pub struct Mode1Plane {
    pub config: Mode1Config,
    pub format: Mode1Format,
    pub scanline_begin: u16,
    pub scanline_end: u16,
    pub config_ptr: u16,
}

impl Mode1Config {
    /// Read config from XRAM at the given pointer.
    pub fn from_xram(xram: &[u8; 65536], ptr: u16) -> Self {
        let p = ptr as usize;
        if p + 16 > 65536 {
            return Self {
                x_wrap: false,
                y_wrap: false,
                x_pos_px: 0,
                y_pos_px: 0,
                width_chars: 0,
                height_chars: 0,
                xram_data_ptr: 0,
                xram_palette_ptr: 0,
                xram_font_ptr: 0,
            };
        }
        Self {
            x_wrap: xram[p] != 0,
            y_wrap: xram[p + 1] != 0,
            x_pos_px: i16::from_le_bytes([xram[p + 2], xram[p + 3]]),
            y_pos_px: i16::from_le_bytes([xram[p + 4], xram[p + 5]]),
            width_chars: i16::from_le_bytes([xram[p + 6], xram[p + 7]]),
            height_chars: i16::from_le_bytes([xram[p + 8], xram[p + 9]]),
            xram_data_ptr: u16::from_le_bytes([xram[p + 10], xram[p + 11]]),
            xram_palette_ptr: u16::from_le_bytes([xram[p + 12], xram[p + 13]]),
            xram_font_ptr: u16::from_le_bytes([xram[p + 14], xram[p + 15]]),
        }
    }
}

/// Resolve font: use XRAM font if pointer is in bounds, else built-in.
/// Matches firmware mode1_get_font():
///   if (font_ptr <= 0x10000 - 256 * font_height) return &xram[font_ptr]
///   else return built-in
fn resolve_font<'a>(xram: &'a [u8; 65536], font_ptr: u16, font_height: i16) -> &'a [u8] {
    let font_size = 256 * font_height as usize;
    if (font_ptr as usize) + font_size <= 0x10000 {
        &xram[font_ptr as usize..font_ptr as usize + font_size]
    } else if font_height == 8 {
        &FONT8
    } else {
        &FONT16
    }
}

/// Resolve fg/bg colors for a single character cell.
/// Returns (bg_rgba, fg_rgba).
fn resolve_cell_colors(
    xram: &[u8; 65536],
    format: &Mode1Format,
    cell_offset: usize,
    palette: &[u32],
) -> (u32, u32) {
    match format {
        Mode1Format::Bpp1_8x8 | Mode1Format::Bpp1_8x16 => {
            // 1bpp: palette[0] = bg, palette[1] = fg
            let bg = if !palette.is_empty() { palette[0] } else { 0 };
            let fg = if palette.len() > 1 { palette[1] } else { 0 };
            (bg, fg)
        }
        Mode1Format::Bpp4r_8x8 | Mode1Format::Bpp4r_8x16 => {
            // 4bpp reversed: byte[1] = fg_bg_index (high=fg, low=bg)
            let fb_byte = xram[cell_offset + 1];
            let fg_idx = (fb_byte >> 4) as usize;
            let bg_idx = (fb_byte & 0x0F) as usize;
            let bg = palette.get(bg_idx).copied().unwrap_or(0);
            let fg = palette.get(fg_idx).copied().unwrap_or(0);
            (bg, fg)
        }
        Mode1Format::Bpp4_8x8 | Mode1Format::Bpp4_8x16 => {
            // 4bpp normal: byte[1] = bg_fg_index (high=bg, low=fg)
            let bf_byte = xram[cell_offset + 1];
            let bg_idx = (bf_byte >> 4) as usize;
            let fg_idx = (bf_byte & 0x0F) as usize;
            let bg = palette.get(bg_idx).copied().unwrap_or(0);
            let fg = palette.get(fg_idx).copied().unwrap_or(0);
            (bg, fg)
        }
        Mode1Format::Bpp8_8x8 | Mode1Format::Bpp8_8x16 => {
            // 8bpp: byte[1] = fg_index, byte[2] = bg_index
            let fg_idx = xram[cell_offset + 1] as usize;
            let bg_idx = xram[cell_offset + 2] as usize;
            let bg = palette.get(bg_idx).copied().unwrap_or(0);
            let fg = palette.get(fg_idx).copied().unwrap_or(0);
            (bg, fg)
        }
        Mode1Format::Bpp16_8x8 | Mode1Format::Bpp16_8x16 => {
            // 16bpp: byte[1] = attributes (ignored), bytes[2..4] = fg_color, bytes[4..6] = bg_color
            let fg_raw = u16::from_le_bytes([
                xram[cell_offset + 2],
                xram[cell_offset + 3],
            ]);
            let bg_raw = u16::from_le_bytes([
                xram[cell_offset + 4],
                xram[cell_offset + 5],
            ]);
            (rgb565_to_rgba(bg_raw), rgb565_to_rgba(fg_raw))
        }
    }
}

/// Render a Mode 1 plane into the framebuffer.
///
/// The framebuffer is an array of RGBA u32 values (R in bits 31:24, G in 23:16,
/// B in 15:8, A in 7:0), laid out as canvas_width x canvas_height pixels.
///
/// Pixels are only written when alpha is non-zero (opaque).
pub fn render_mode1(
    plane: &Mode1Plane,
    xram: &[u8; 65536],
    framebuffer: &mut [u32],
    canvas_width: u16,
    canvas_height: u16,
) {
    let cfg = &plane.config;
    let font_height = plane.format.font_height();
    let cell_size = plane.format.cell_size();

    if cfg.width_chars < 1 || cfg.height_chars < 1 {
        return;
    }

    // Bounds check: character data must fit in XRAM
    let height_px = cfg.height_chars as i32 * font_height as i32;
    let sizeof_row = cfg.width_chars as usize * cell_size;
    let sizeof_data = cfg.height_chars as usize * sizeof_row;
    if sizeof_data > 0x10000usize.saturating_sub(cfg.xram_data_ptr as usize) {
        return;
    }

    let font = resolve_font(xram, cfg.xram_font_ptr, font_height);
    let palette = resolve_palette(xram, plane.format.bpp(), cfg.xram_palette_ptr);

    let y_start = plane.scanline_begin as i32;
    let y_end = if plane.scanline_end == 0 {
        canvas_height as i32
    } else {
        plane.scanline_end as i32
    };

    let width_px = cfg.width_chars as i32 * 8;

    for scanline in y_start..y_end {
        if scanline < 0 || scanline >= canvas_height as i32 {
            continue;
        }

        let mut row = scanline - cfg.y_pos_px as i32;

        // Y wrapping on height_chars * font_height pixels
        if cfg.y_wrap {
            row = row.rem_euclid(height_px);
        }

        if row < 0 || row >= height_px {
            continue;
        }

        let char_row = row / font_height as i32;
        let font_row_in_glyph = row & (font_height as i32 - 1);
        let font_row_offset = (font_row_in_glyph as usize) * 256;
        let row_data_offset = cfg.xram_data_ptr as usize + char_row as usize * sizeof_row;

        for screen_x in 0..canvas_width as i32 {
            let mut col = screen_x - cfg.x_pos_px as i32;

            // X wrapping on width_chars * 8 pixels
            if cfg.x_wrap {
                col = col.rem_euclid(width_px);
            }

            if col < 0 || col >= width_px {
                continue;
            }

            let char_col = col / 8;
            let bit_in_char = 7 - (col & 7); // MSB first

            let cell_offset = row_data_offset + char_col as usize * cell_size;
            if cell_offset >= 0x10000 {
                continue;
            }

            let glyph_code = xram[cell_offset] as usize;
            let font_byte = font[font_row_offset + glyph_code];
            let bit = (font_byte >> bit_in_char) & 1;

            let (bg, fg) = resolve_cell_colors(xram, &plane.format, cell_offset, &palette);
            let rgba = if bit == 1 { fg } else { bg };

            if rgba & 0xFF != 0 {
                let fb_idx = scanline as usize * canvas_width as usize + screen_x as usize;
                framebuffer[fb_idx] = rgba;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vga::palette::PALETTE_256;

    fn make_mode1_xram(
        config_ptr: u16,
        data_ptr: u16,
        width_chars: i16,
        height_chars: i16,
    ) -> Box<[u8; 65536]> {
        let mut xram = Box::new([0u8; 65536]);
        let p = config_ptr as usize;
        xram[p] = 0;     // x_wrap = false
        xram[p + 1] = 0; // y_wrap = false
        xram[p + 2..p + 4].copy_from_slice(&0i16.to_le_bytes()); // x_pos = 0
        xram[p + 4..p + 6].copy_from_slice(&0i16.to_le_bytes()); // y_pos = 0
        xram[p + 6..p + 8].copy_from_slice(&width_chars.to_le_bytes());
        xram[p + 8..p + 10].copy_from_slice(&height_chars.to_le_bytes());
        xram[p + 10..p + 12].copy_from_slice(&data_ptr.to_le_bytes());
        xram[p + 12..p + 14].copy_from_slice(&0xFFFFu16.to_le_bytes()); // palette_ptr = 0xFFFF (built-in)
        xram[p + 14..p + 16].copy_from_slice(&0xFFFFu16.to_le_bytes()); // font_ptr = 0xFFFF (built-in)
        xram
    }

    #[test]
    fn test_mode1_1bpp_single_char() {
        let config_ptr = 0x0000u16;
        let data_ptr = 0x0100u16;
        // 1 char wide, 1 char tall, 8x8 font
        let xram = make_mode1_xram(config_ptr, data_ptr, 1, 1);

        // Write glyph 0xDB (full block = all 0xFF in font)
        // xram[data_ptr] is already 0 but we set glyph 0xDB
        let mut xram = xram;
        xram[data_ptr as usize] = 0xDB;

        let plane = Mode1Plane {
            config: Mode1Config::from_xram(&xram, config_ptr),
            format: Mode1Format::Bpp1_8x8,
            scanline_begin: 0,
            scanline_end: 8,
            config_ptr,
        };

        // Canvas is 8x8 to fit exactly one character
        let mut fb = vec![0u32; 8 * 8];
        render_mode1(&plane, &xram, &mut fb, 8, 8);

        // Full block: every pixel should be palette[1] (fg, opaque)
        for y in 0..8 {
            for x in 0..8 {
                let px = fb[y * 8 + x];
                assert_ne!(px & 0xFF, 0, "pixel ({x},{y}) should be opaque");
            }
        }
    }

    #[test]
    fn test_mode1_1bpp_space_is_transparent() {
        let config_ptr = 0x0000u16;
        let data_ptr = 0x0100u16;
        let xram = make_mode1_xram(config_ptr, data_ptr, 1, 1);
        // glyph 0x20 (space) = all zeros, so all pixels should be bg (transparent for 1bpp)
        let mut xram = xram;
        xram[data_ptr as usize] = 0x20;

        let plane = Mode1Plane {
            config: Mode1Config::from_xram(&xram, config_ptr),
            format: Mode1Format::Bpp1_8x8,
            scanline_begin: 0,
            scanline_end: 8,
            config_ptr,
        };

        let mut fb = vec![0u32; 8 * 8];
        render_mode1(&plane, &xram, &mut fb, 8, 8);

        // Space with 1bpp default palette: bg is palette[0] which is transparent
        for y in 0..8 {
            for x in 0..8 {
                assert_eq!(fb[y * 8 + x], 0, "pixel ({x},{y}) should be transparent");
            }
        }
    }

    #[test]
    fn test_mode1_8bpp_fg_bg_colors() {
        let config_ptr = 0x0000u16;
        let data_ptr = 0x0100u16;
        let mut xram = make_mode1_xram(config_ptr, data_ptr, 1, 1);
        // 8bpp cell: glyph_code, fg_index, bg_index
        xram[data_ptr as usize] = 0xDB;     // full block
        xram[data_ptr as usize + 1] = 9;    // fg = bright red
        xram[data_ptr as usize + 2] = 12;   // bg = bright blue

        let plane = Mode1Plane {
            config: Mode1Config::from_xram(&xram, config_ptr),
            format: Mode1Format::Bpp8_8x8,
            scanline_begin: 0,
            scanline_end: 8,
            config_ptr,
        };

        let mut fb = vec![0u32; 8 * 8];
        render_mode1(&plane, &xram, &mut fb, 8, 8);

        // Full block: all pixels should be fg color (bright red = PALETTE_256[9])
        for y in 0..8 {
            for x in 0..8 {
                assert_eq!(fb[y * 8 + x], PALETTE_256[9],
                    "pixel ({x},{y}) should be bright red");
            }
        }
    }

    #[test]
    fn test_mode1_config_from_xram() {
        let mut xram = Box::new([0u8; 65536]);
        let p = 0x100usize;
        xram[p] = 1;     // x_wrap
        xram[p + 1] = 0; // y_wrap
        xram[p + 2..p + 4].copy_from_slice(&10i16.to_le_bytes());  // x_pos
        xram[p + 4..p + 6].copy_from_slice(&20i16.to_le_bytes());  // y_pos
        xram[p + 6..p + 8].copy_from_slice(&40i16.to_le_bytes());  // width_chars
        xram[p + 8..p + 10].copy_from_slice(&30i16.to_le_bytes()); // height_chars
        xram[p + 10..p + 12].copy_from_slice(&0x2000u16.to_le_bytes()); // data_ptr
        xram[p + 12..p + 14].copy_from_slice(&0x4000u16.to_le_bytes()); // palette_ptr
        xram[p + 14..p + 16].copy_from_slice(&0xFFFFu16.to_le_bytes()); // font_ptr

        let cfg = Mode1Config::from_xram(&xram, 0x100);
        assert!(cfg.x_wrap);
        assert!(!cfg.y_wrap);
        assert_eq!(cfg.x_pos_px, 10);
        assert_eq!(cfg.y_pos_px, 20);
        assert_eq!(cfg.width_chars, 40);
        assert_eq!(cfg.height_chars, 30);
        assert_eq!(cfg.xram_data_ptr, 0x2000);
        assert_eq!(cfg.xram_palette_ptr, 0x4000);
        assert_eq!(cfg.xram_font_ptr, 0xFFFF);
    }

    #[test]
    fn test_mode1_format_from_attr() {
        assert_eq!(Mode1Format::from_attr(0), Some(Mode1Format::Bpp1_8x8));
        assert_eq!(Mode1Format::from_attr(1), Some(Mode1Format::Bpp4r_8x8));
        assert_eq!(Mode1Format::from_attr(2), Some(Mode1Format::Bpp4_8x8));
        assert_eq!(Mode1Format::from_attr(3), Some(Mode1Format::Bpp8_8x8));
        assert_eq!(Mode1Format::from_attr(4), Some(Mode1Format::Bpp16_8x8));
        assert_eq!(Mode1Format::from_attr(8), Some(Mode1Format::Bpp1_8x16));
        assert_eq!(Mode1Format::from_attr(12), Some(Mode1Format::Bpp16_8x16));
        assert_eq!(Mode1Format::from_attr(5), None);
        assert_eq!(Mode1Format::from_attr(7), None);
    }

    #[test]
    fn test_mode1_y_wrap() {
        let config_ptr = 0x0000u16;
        let data_ptr = 0x0100u16;
        let mut xram = make_mode1_xram(config_ptr, data_ptr, 1, 1);
        // Enable y_wrap
        xram[config_ptr as usize] = 0; // x_wrap off
        xram[config_ptr as usize + 1] = 1; // y_wrap on
        // Full block glyph
        xram[data_ptr as usize] = 0xDB;

        let plane = Mode1Plane {
            config: Mode1Config::from_xram(&xram, config_ptr),
            format: Mode1Format::Bpp1_8x8,
            scanline_begin: 0,
            scanline_end: 16, // 16 scanlines but only 1 char tall (8px), should wrap
            config_ptr,
        };

        let mut fb = vec![0u32; 8 * 16];
        render_mode1(&plane, &xram, &mut fb, 8, 16);

        // Row 0 and row 8 should both have content (wrapped)
        assert_ne!(fb[0] & 0xFF, 0, "row 0 should have content");
        assert_ne!(fb[8 * 8] & 0xFF, 0, "row 8 should wrap and have content");
    }
}
```

**Step 2: Add `pub mod mode1;` to vga/mod.rs**

In `emu/src/vga/mod.rs`, add after `pub mod font;`:

```rust
pub mod mode1;
```

**Step 3: Run tests**

Run: `cd /home/sprite/rp6502/emu && cargo test vga::mode1 -- --nocapture`
Expected: All 7 Mode 1 tests pass.

**Step 4: Run full test suite**

Run: `cd /home/sprite/rp6502/emu && cargo test`
Expected: All tests pass.

**Step 5: Commit**

```bash
git add emu/src/vga/mode1.rs emu/src/vga/mod.rs
git commit -m "feat: add Mode 1 (Character) renderer

Supports all 5 color depths (1/4/4r/8/16 bpp) and both font sizes
(8x8 and 8x16). Per-scanline rendering with X/Y wrapping, built-in
font fallback, and shared palette resolution."
```

---

### Task 4: Integrate Mode 1 into VGA state machine

Change `vga/mod.rs` to use a `Plane` enum supporting both Mode 1 and Mode 3, add `program_mode1()`, and update `render_frame()`.

**Files:**
- Modify: `emu/src/vga/mod.rs`

**Step 1: Update imports and plane type**

In `emu/src/vga/mod.rs`, replace the imports and `Vga` struct definition.

Change line 7:
```rust
use mode3::{ColorFormat, Mode3Config, Mode3Plane, render_mode3};
```
to:
```rust
use mode1::{Mode1Config, Mode1Format, Mode1Plane, render_mode1};
use mode3::{ColorFormat, Mode3Config, Mode3Plane, render_mode3};
```

Add a `Plane` enum before the `Vga` struct:

```rust
/// A programmed display plane, which may be Mode 1 or Mode 3.
#[derive(Debug, Clone)]
pub enum Plane {
    Mode1(Mode1Plane),
    Mode3(Mode3Plane),
}
```

Change the `planes` field type in `Vga` struct from:
```rust
pub planes: [Option<Mode3Plane>; 3],
```
to:
```rust
pub planes: [Option<Plane>; 3],
```

**Step 2: Add `program_mode1()` method**

Add after `program_mode3()`:

```rust
/// Program Mode 1 from accumulated xregs.
/// Same xregs layout as Mode 3:
///   xregs[2] = attributes (format: font size + color depth)
///   xregs[3] = config_ptr (XRAM address of Mode1Config)
///   xregs[4] = plane index (0-2)
///   xregs[5] = scanline_begin
///   xregs[6] = scanline_end (0 = canvas height)
fn program_mode1(&mut self) {
    let attr = self.xregs[2];
    let config_ptr = self.xregs[3];
    let plane_idx = self.xregs[4] as usize;
    let scanline_begin = self.xregs[5];
    let scanline_end = self.xregs[6];

    if plane_idx >= 3 || config_ptr & 1 != 0 {
        return;
    }

    // Additional firmware check: config_ptr must leave room for the 16-byte struct
    if config_ptr as usize + 16 > 0x10000 {
        return;
    }

    let format = match Mode1Format::from_attr(attr) {
        Some(f) => f,
        None => return,
    };

    let config = Mode1Config::from_xram(&self.xram, config_ptr);

    self.planes[plane_idx] = Some(Plane::Mode1(Mode1Plane {
        config,
        format,
        scanline_begin,
        scanline_end,
        config_ptr,
    }));
}
```

**Step 3: Update `handle_reg()` MODE case**

Change the MODE match arm (around line 146-157) from:
```rust
1 => {
    // MODE - program a graphics mode
    let mode = reg.value;
    if mode == 3 {
        self.program_mode3();
        let _ = self.backchannel_tx.send(Backchannel::Ack);
    } else {
        // Only Mode 3 supported in MVP
        let _ = self.backchannel_tx.send(Backchannel::Nak);
    }
    self.xregs = [0; 8];
}
```
to:
```rust
1 => {
    // MODE - program a graphics mode
    let mode = reg.value;
    match mode {
        1 => {
            self.program_mode1();
            let _ = self.backchannel_tx.send(Backchannel::Ack);
        }
        3 => {
            self.program_mode3();
            let _ = self.backchannel_tx.send(Backchannel::Ack);
        }
        _ => {
            let _ = self.backchannel_tx.send(Backchannel::Nak);
        }
    }
    self.xregs = [0; 8];
}
```

**Step 4: Update `program_mode3()` to wrap in `Plane::Mode3`**

Change the last line of `program_mode3()` from:
```rust
self.planes[plane_idx] = Some(Mode3Plane {
```
to:
```rust
self.planes[plane_idx] = Some(Plane::Mode3(Mode3Plane {
```
and add `));` at the end.

**Step 5: Update `render_frame()` to dispatch by plane type**

Change the render loop from:
```rust
for plane in self.planes.iter().flatten() {
    let fresh_config = Mode3Config::from_xram(&self.xram, plane.config_ptr);
    let current_plane = Mode3Plane { config: fresh_config, ..plane.clone() };
    render_mode3(&current_plane, &self.xram, &mut self.canvas_buf[..pixel_count], w, h);
}
```
to:
```rust
for plane in self.planes.iter().flatten() {
    match plane {
        Plane::Mode1(p) => {
            let fresh_config = Mode1Config::from_xram(&self.xram, p.config_ptr);
            let current_plane = Mode1Plane { config: fresh_config, ..p.clone() };
            render_mode1(&current_plane, &self.xram, &mut self.canvas_buf[..pixel_count], w, h);
        }
        Plane::Mode3(p) => {
            let fresh_config = Mode3Config::from_xram(&self.xram, p.config_ptr);
            let current_plane = Mode3Plane { config: fresh_config, ..p.clone() };
            render_mode3(&current_plane, &self.xram, &mut self.canvas_buf[..pixel_count], w, h);
        }
    }
}
```

**Step 6: Update CANVAS reset**

The CANVAS handler resets planes. Change from:
```rust
self.planes = [None, None, None];
```
This stays the same — `[Option<Plane>; 3]` defaults to `[None, None, None]`.

**Step 7: Run full test suite**

Run: `cd /home/sprite/rp6502/emu && cargo test`
Expected: All tests pass.

**Step 8: Commit**

```bash
git add emu/src/vga/mod.rs
git commit -m "feat: integrate Mode 1 into VGA state machine

Add Plane enum for Mode 1/Mode 3 dispatch. VGA now accepts
MODE=1 register writes and renders character planes alongside
bitmap planes."
```

---

### Task 5: Add Mode 1 test harness modes and CLI support

Add Mode 1 test patterns to the test harness so they can be visually verified with screenshots.

**Files:**
- Modify: `emu/src/test_harness.rs` (add Mode 1 variants and trace generation)

**Step 1: Add Mode 1 TestMode variants**

In `emu/src/test_harness.rs`, add two new variants to the `TestMode` enum after `Color16bpp320`:

```rust
/// 320x240 canvas, Mode 1, 1bpp 8x16 font (40x15 chars)
Text1bpp320x240,
/// 320x240 canvas, Mode 1, 8bpp 8x8 font (40x30 chars)
Text8bpp320x240,
```

Update `Display`, `FromStr`, and `all()` to include the new variants:

In `Display`:
```rust
TestMode::Text1bpp320x240 => "text1bpp320x240",
TestMode::Text8bpp320x240 => "text8bpp320x240",
```

In `FromStr`:
```rust
"text1bpp320x240" => Ok(TestMode::Text1bpp320x240),
"text8bpp320x240" => Ok(TestMode::Text8bpp320x240),
```

In `all()`:
```rust
TestMode::Text1bpp320x240,
TestMode::Text8bpp320x240,
```

**Step 2: Add Mode 1 trace generation**

Add a new function after `generate_test_trace`:

```rust
/// Generate a bus trace that programs Mode 1 with a test pattern.
///
/// The trace:
/// 1. Writes a Mode1Config struct to XRAM at address 0x0000 via ADDR0/RW0
/// 2. Writes character data at address 0x0100 via ADDR0/RW0
/// 3. Configures VGA via xreg: CANVAS, MODE=1, attr, config_ptr=0
/// 4. Exits after one frame worth of cycles
pub fn generate_mode1_test_trace(mode: TestMode) -> Vec<BusTransaction> {
    let mut trace = Vec::new();
    let mut cycle: u64 = 0;

    let config_ptr: u16 = 0x0000;
    let data_ptr: u16 = 0x0100;

    let (width_chars, height_chars, attr, cell_size): (i16, i16, u16, usize) = match mode {
        TestMode::Text1bpp320x240 => (40, 15, 8, 1),   // 8x16, 1bpp
        TestMode::Text8bpp320x240 => (40, 30, 3, 3),   // 8x8, 8bpp
        _ => panic!("Not a Mode 1 test mode"),
    };

    // --- Step 1: Write Mode1Config (16 bytes) to XRAM ---
    trace.push(BusTransaction::write(cycle, 0xFFE6, (config_ptr & 0xFF) as u8));
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFE7, (config_ptr >> 8) as u8));
    cycle += 1;

    let config_bytes: [u8; 16] = [
        0, 0,                                                          // x_wrap=false, y_wrap=false
        0, 0,                                                          // x_pos_px = 0
        0, 0,                                                          // y_pos_px = 0
        (width_chars & 0xFF) as u8, (width_chars >> 8) as u8,         // width_chars
        (height_chars & 0xFF) as u8, (height_chars >> 8) as u8,       // height_chars
        (data_ptr & 0xFF) as u8, (data_ptr >> 8) as u8,               // xram_data_ptr
        0xFF, 0xFF,                                                     // xram_palette_ptr = 0xFFFF (built-in)
        0xFF, 0xFF,                                                     // xram_font_ptr = 0xFFFF (built-in)
    ];
    for &b in &config_bytes {
        trace.push(BusTransaction::write(cycle, 0xFFE4, b));
        cycle += 1;
    }

    // --- Step 2: Write character data ---
    trace.push(BusTransaction::write(cycle, 0xFFE6, (data_ptr & 0xFF) as u8));
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFE7, (data_ptr >> 8) as u8));
    cycle += 1;

    for row in 0..height_chars as u32 {
        for col in 0..width_chars as u32 {
            // Cycle through printable ASCII glyphs
            let glyph = 0x21 + ((row * width_chars as u32 + col) % 94) as u8; // '!' to '~'
            trace.push(BusTransaction::write(cycle, 0xFFE4, glyph));
            cycle += 1;

            if cell_size >= 2 {
                // 8bpp: fg_index, bg_index
                let fg = (1 + (col % 15)) as u8;       // colors 1-15 (avoid 0 = transparent)
                let bg = 16;                             // opaque black (grey0)
                trace.push(BusTransaction::write(cycle, 0xFFE4, fg));
                cycle += 1;
                if cell_size >= 3 {
                    trace.push(BusTransaction::write(cycle, 0xFFE4, bg));
                    cycle += 1;
                }
            }
        }
    }

    // --- Step 3: Configure VGA via xreg ---
    // First xreg: CANVAS (320x240 = canvas value 1)
    trace.push(BusTransaction::write(cycle, 0xFFEC, 1)); // device
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFEC, 0)); // channel
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFEC, 0)); // start_addr
    cycle += 1;
    let canvas: u16 = 1; // 320x240
    trace.push(BusTransaction::write(cycle, 0xFFEC, (canvas >> 8) as u8));
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFEC, (canvas & 0xFF) as u8));
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFEF, 0x01)); // trigger xreg
    cycle += 1;

    // Second xreg: MODE=1 + attributes
    trace.push(BusTransaction::write(cycle, 0xFFEC, 1)); // device
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFEC, 0)); // channel
    cycle += 1;
    trace.push(BusTransaction::write(cycle, 0xFFEC, 1)); // start_addr=1 (MODE register)
    cycle += 1;
    let reg_values: [u16; 6] = [
        1,              // reg 1: MODE = Mode 1 (Character)
        attr,           // reg 2: attributes
        config_ptr,     // reg 3: config_ptr
        0,              // reg 4: plane = 0
        0,              // reg 5: scanline_begin = 0
        0,              // reg 6: scanline_end = 0 (= canvas height)
    ];
    for &val in &reg_values {
        trace.push(BusTransaction::write(cycle, 0xFFEC, (val >> 8) as u8));
        cycle += 1;
        trace.push(BusTransaction::write(cycle, 0xFFEC, (val & 0xFF) as u8));
        cycle += 1;
    }
    trace.push(BusTransaction::write(cycle, 0xFFEF, 0x01)); // trigger xreg
    cycle += 1;

    // Wait one frame then exit
    trace.push(BusTransaction::write(cycle + 200_000, 0xFFEF, 0xFF));

    trace
}
```

**Step 3: Update `generate_test_trace` to dispatch Mode 1 modes**

Change the existing `generate_test_trace` function. At the very start, add a dispatch:

```rust
pub fn generate_test_trace(mode: TestMode) -> Vec<BusTransaction> {
    match mode {
        TestMode::Text1bpp320x240 | TestMode::Text8bpp320x240 => {
            return generate_mode1_test_trace(mode);
        }
        _ => {}
    }

    // ... existing Mode 3 trace generation code ...
```

**Step 4: Run tests**

Run: `cd /home/sprite/rp6502/emu && cargo test`
Expected: All tests pass, including the existing test_all_modes_produce_traces which now covers Mode 1 variants.

**Step 5: Commit**

```bash
git add emu/src/test_harness.rs
git commit -m "feat: add Mode 1 test harness modes

text1bpp320x240: monochrome text, 40x15 chars, 8x16 font
text8bpp320x240: colored text, 40x30 chars, 8x8 font"
```

---

### Task 6: End-to-end verification with screenshots

Verify the full pipeline works by generating Mode 1 screenshots.

**Step 1: Run a Mode 1 screenshot**

Run: `cd /home/sprite/rp6502/emu && cargo run -- screenshot --mode text1bpp320x240 -o /tmp/text1bpp.png`
Expected: Produces a PNG showing monochrome text characters (printable ASCII cycling).

**Step 2: Run the colored text screenshot**

Run: `cd /home/sprite/rp6502/emu && cargo run -- screenshot --mode text8bpp320x240 -o /tmp/text8bpp.png`
Expected: Produces a PNG showing colored text on black background.

**Step 3: Verify screenshots look correct**

Open both PNGs and verify:
- `text1bpp.png`: Light grey text on transparent/black background, readable character shapes, 40 columns
- `text8bpp.png`: Multi-colored text on black background, readable 8x8 characters, 40 columns x 30 rows

**Step 4: Run full test suite one final time**

Run: `cd /home/sprite/rp6502/emu && cargo test`
Expected: All tests pass.

---

## Out of Scope

- Code pages other than CP437
- Custom font loading via XRAM (test infrastructure only uses built-in fonts)
- Mode 0 (Console), Mode 2 (Tile), Mode 4 (Sprite)
- Performance optimization of the pixel-by-pixel renderer
