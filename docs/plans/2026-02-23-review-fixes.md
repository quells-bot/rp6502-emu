# Review Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix the XSTACK pop off-by-one bug and make built-in palettes pixel-exact with hardware by round-tripping through 5-bit quantization.

**Architecture:** Two independent fixes. The XSTACK fix changes `handle_read` to return the current register value (already set by the previous push/pop) and defer the pointer update. The palette fix replaces hand-written RGBA constants with values generated by the same `PICO_SCANVIDEO_PIXEL_FROM_RGB8` → `rgb565_to_rgba` path the hardware uses.

**Tech Stack:** Rust, existing `emu/` crate

---

### Task 1: Fix XSTACK pop to return current TOS

The XSTACK register ($FFEC) is continuously visible to the 6502 via the register file. On real hardware, the 6502 reads the *current* register value (set by the last push or pop), and the RIA action loop updates the pointer and register *afterward*. The emulator's `handle_read` incorrectly increments the pointer before reading, returning one-past-TOS instead of TOS.

**Files:**
- Modify: `emu/src/ria.rs:330-336` (handle_read XSTACK case)
- Modify: `emu/src/ria.rs:515-531` (test_xstack_push_pop)

**Step 1: Fix the existing test to assert correct LIFO behavior**

The test currently asserts the wrong value. Fix it to match hardware semantics:

```rust
#[test]
fn test_xstack_push_pop() {
    let (mut ria, _, _) = make_ria();
    // Push 0x42
    ria.process(&BusTransaction::write(1, 0xFFEC, 0x42));
    assert_eq!(ria.xstack_ptr, XSTACK_SIZE - 1);
    assert_eq!(ria.regs[0x0C], 0x42);

    // Push 0x43
    ria.process(&BusTransaction::write(2, 0xFFEC, 0x43));
    assert_eq!(ria.xstack_ptr, XSTACK_SIZE - 2);
    assert_eq!(ria.regs[0x0C], 0x43);

    // Pop (read) — 6502 sees current register value (0x43, set by last push)
    let val = ria.process(&BusTransaction::read(3, 0xFFEC, 0));
    assert_eq!(val, 0x43); // TOS was 0x43
    assert_eq!(ria.xstack_ptr, XSTACK_SIZE - 1);
    // After pop, register now reflects new TOS
    assert_eq!(ria.regs[0x0C], 0x42);

    // Pop again — 6502 sees 0x42 (set by previous pop's update)
    let val2 = ria.process(&BusTransaction::read(4, 0xFFEC, 0));
    assert_eq!(val2, 0x42);
    assert_eq!(ria.xstack_ptr, XSTACK_SIZE);
    // Stack empty — reads zero sentinel
    assert_eq!(ria.regs[0x0C], 0);
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test -p emu test_xstack_push_pop -- --nocapture`
Expected: FAIL — returns 0x42 instead of 0x43 for first pop.

**Step 3: Fix handle_read XSTACK case**

In `emu/src/ria.rs`, change the `0x0C` match arm in `handle_read`:

```rust
// $FFEC: XSTACK pop
// The 6502 sees the current register value (set by previous push/pop).
// We return that, then update pointer and register for next access.
0x0C => {
    let val = self.regs[0x0C];
    if self.xstack_ptr < XSTACK_SIZE {
        self.xstack_ptr += 1;
    }
    self.regs[0x0C] = self.xstack[self.xstack_ptr];
    val
}
```

**Step 4: Run test to verify it passes**

Run: `cargo test -p emu test_xstack_push_pop -- --nocapture`
Expected: PASS

**Step 5: Run full test suite**

Run: `cargo test -p emu`
Expected: All tests pass.

**Step 6: Commit**

```bash
git add emu/src/ria.rs
git commit -m "fix: XSTACK pop returns current TOS before advancing pointer

The 6502 reads the register value set by the previous push/pop.
The action loop then advances the pointer for the next access.
The old code incremented the pointer before reading, skipping
the actual TOS and returning one-past-TOS instead."
```

---

### Task 2: Make built-in palettes pixel-exact via 5-bit round-trip

The hardware stores palette colors as 16-bit PICO_SCANVIDEO values (5 bits per channel). The emulator's built-in palettes use raw RGB8 values, which differ by ~1 LSB after quantization. For digital-twin accuracy, generate palette values through the same path: RGB8 → 16-bit PICO → RGBA.

**Files:**
- Modify: `emu/src/vga/palette.rs` (PALETTE_2, PALETTE_256, add helper)

**Step 1: Add a const round-trip helper**

Add a `const fn` that takes RGB8 and produces the RGBA u32 as if the hardware had processed it (8→5→8 bit quantization, alpha set):

```rust
/// Convert RGB8 to RGBA u32 through the PICO_SCANVIDEO 5-bit round-trip.
/// This matches the exact pixel values the real hardware produces.
/// Path: RGB8 → PICO_SCANVIDEO (5-bit per channel + alpha) → RGBA u32.
const fn pico_rgba(r: u8, g: u8, b: u8) -> u32 {
    let r5 = r >> 3;
    let g5 = g >> 3;
    let b5 = b >> 3;
    let r8 = (r5 << 3) | (r5 >> 2);
    let g8 = (g5 << 3) | (g5 >> 2);
    let b8 = (b5 << 3) | (b5 >> 2);
    ((r8 as u32) << 24) | ((g8 as u32) << 16) | ((b8 as u32) << 8) | 0xFF
}

/// Same as pico_rgba but with alpha=0 (transparent).
const fn pico_rgba_transparent(r: u8, g: u8, b: u8) -> u32 {
    let r5 = r >> 3;
    let g5 = g >> 3;
    let b5 = b >> 3;
    let r8 = (r5 << 3) | (r5 >> 2);
    let g8 = (g5 << 3) | (g5 >> 2);
    let b8 = (b5 << 3) | (b5 >> 2);
    ((r8 as u32) << 24) | ((g8 as u32) << 16) | ((b8 as u32) << 8)
}
```

**Step 2: Write a test that verifies round-trip consistency**

The test ensures `pico_rgba` matches what `rgb565_to_rgba` would produce for the same input:

```rust
#[test]
fn test_pico_rgba_matches_rgb565_roundtrip() {
    // Build the 16-bit PICO value for (205, 0, 0) the way hardware does
    let r5 = 205u16 >> 3; // 25
    let g5 = 0u16 >> 3;   // 0
    let b5 = 0u16 >> 3;   // 0
    let alpha = 1u16 << 5;
    let pico16 = (b5 << 11) | (g5 << 6) | alpha | r5;
    let from_hw = rgb565_to_rgba(pico16);
    let from_fn = pico_rgba(205, 0, 0);
    assert_eq!(from_hw, from_fn);
}
```

**Step 3: Run test to verify it passes**

Run: `cargo test -p emu test_pico_rgba_matches_rgb565_roundtrip -- --nocapture`
Expected: PASS

**Step 4: Replace `rgba`/`rgba_transparent` with `pico_rgba`/`pico_rgba_transparent` in palette definitions**

In `PALETTE_2`:
```rust
pub const PALETTE_2: [u32; 2] = [
    pico_rgba_transparent(0, 0, 0),
    pico_rgba(192, 192, 192),
];
```

In `PALETTE_256` — replace every `rgba(` with `pico_rgba(` and `rgba_transparent(` with `pico_rgba_transparent(`. The only transparent entry is index 0.

Also update the RGB cube and greyscale ramp loops to use `pico_rgba` instead of `rgba`.

**Step 5: Update palette tests for quantized values**

The test `test_palette_256_ansi_colors` asserts `rgba(205, 0, 0)` for index 1. After the change, the value will be `pico_rgba(205, 0, 0)` which is `rgba(206, 0, 0)` (205→R5=25→206). Update assertions:

```rust
#[test]
fn test_palette_256_ansi_colors() {
    // Black is transparent
    assert_eq!(PALETTE_256[0] & 0xFF, 0x00);
    // Red: 205 → R5=25 → 206
    assert_eq!(PALETTE_256[1], pico_rgba(205, 0, 0));
    // Grey0 (index 16) is opaque black
    assert_eq!(PALETTE_256[16], pico_rgba(0, 0, 0));
    // Bright white
    assert_eq!(PALETTE_256[15], pico_rgba(255, 255, 255));
}
```

Similarly update `test_palette_256_rgb_cube` and `test_palette_256_greyscale`.

**Step 6: Run full test suite**

Run: `cargo test -p emu`
Expected: All tests pass.

**Step 7: Commit**

```bash
git add emu/src/vga/palette.rs
git commit -m "fix: built-in palettes use 5-bit round-trip for pixel-exact hardware match

The real hardware stores palette colors as 16-bit PICO_SCANVIDEO values
(5 bits per channel). Generate emulator palettes through the same
RGB8 → 5-bit → RGB8 quantization path so pixel values exactly match
what the hardware DAC produces."
```

---

## Out of Scope (documented for future work)

These issues were identified in the review but are not addressed in this plan:

1. **Combined canvas+mode xreg special case** — The firmware sends CANVAS first and waits for ACK before sending MODE attrs. The emulator sends all registers in reverse. Real SDK code that combines both in one `xreg()` call would silently fail. Tracked for post-MVP when real 6502 programs are tested.

2. **xreg ack/nak state machine** — The firmware's async state machine with 2ms timeout is simplified to synchronous fire-and-forget. Acceptable for MVP.

3. **palette_ptr=0 semantics** — Documented divergence: emulator treats 0 as "use built-in" while firmware reads XRAM[0]. Low risk since XRAM[0] typically holds the config struct.
